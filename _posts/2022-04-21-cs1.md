---
title: "컴퓨터 구조: H/W, 진법 변환, 가산기"

categories:
  - cs
tags:
  - [컴퓨터 구조, H/W, 2진수, 16진수, 가산기]

toc: true
toc_sticky: true
comments: true
use_math: true
date: 2022-04-20
last_modified_at: 2022-04-20
---

📌 **작성자 개발 환경** <br>
**OS** : Windows 10 <br>
**Language** : None<br>
**Tool** : None<br>
{: .notice--primary}

# 컴퓨터 구조

- 컴퓨터는 아래 요소로 구성되어 있다.
  - 하드웨어(H/W)
  - 소프트웨어(S/W): 시스템 S/W, 응용 S/W

## 하드웨어

- 아래 H/W 구성과 역할을 정리하였다.
<br><br>

### 메인보드의 구조 ([그림 출처](https://coolenjoy.net/bbs/27/36967))

<p align="center"><img src="/assets/images/mainboard.bmp" width="862px" height="697px"></p>

### CPU
- None

### RAM
- None

### SSD/HDD
- None

### VGA GPU 모니터
- None

<br>

# 컴퓨터의 CPU & Memory

- 컴퓨터의 구조에서 가장 중요한 것은 **CPU**와 **Memory**라고 할 수 있다.
- 컴퓨터 내 모든 정보는 숫자로만 이루어져있으며, **CPU**를 통해 숫자 정보를 연산하고, **Memory**에 정보들을 저장한다.
- 또한 CPU의 **연산 기능(계산기)**이 컴퓨터의 모든 것을 구현한다고 말할 수 있다.
- CPU와 Memory를 이해하기 위해 아래에 대한 학습이 필요하다.
  1. bit, byte, 2진수, 16진수, 진법 변환 등
  2. 반가산기, 전가산기 등 디지털 회로
<br><br>

## bit (2진수)

- 1bit는 **On/Off가 가능한 1개의 스위치**를 의미한다.
- bit는 binary digit(2진수)의 줄인말
- 예를 들어, 4 bit는 4개의 On/Off 스위치를 의미하며, 구현가능한 모든 경우의 수는 16가지이다.
  - 4 bit = 2^4 = 16
  - 2진수 4개(4 bit)로 표현할 수 있는 10진수의 양수로 보면 0~15까지
  - 0000 = 0
  - 0001 = $2^0$ = 1
  - 0010 = $2^1$ = 2
  - 0011 = $2^1 + 2^0$ = 3<br>
     ...
  - 1111 = $2^1 + 2^0$ 15

- 위와 같이 2진수를 주로 사용되는 10진수로 표현하는 등 다른 진수로 표현하는 것을 **진법 변환**이라 한다.


### bit와 byte

- byte의 정의
> The byte was the number of bits used to encode a single character of text in a computer (i.e. 8 bits per character)
- 일반적으로 8 bit(8개 스위치)를 하나로 묶어 1 byte라 한다.

- 메모리(Memory)
  - 컴퓨터의 **자료(또는 정보)**는 **숫자**를 의미한다
  - 컴퓨터에서는 정보를 어딘가에 보관해야하고, 그곳이 **메모리(Memory)**다.
  - 메모리 안에 보관되어 있는 정보를 넣거나 빼는 등 관리를 통해 정보가 움직인다.
  - 컴퓨터는 0️⃣1️⃣2️⃣3️⃣4️⃣5️⃣의 형태처럼 메모리 내 각 공간에 번호를 붙여 자료(정보)를 관리
  - 각 공간에 저장할 수 있는 기억 공간의 크기는 **1 byte (8 bit)**<br>
  - 메모리에서 하나의 주소(1 byte, 0️⃣)에 저장할 수 있는 정보는 영문 1글자(예: hello는 5byte), 한글은 1글자에 2 byte가 필요하다.
  - 0️⃣1️⃣2️⃣3️⃣4️⃣5️⃣... 각 공간의 위치를 나타내는 번호를 **주소(address)**라고 하며, 1 byte = 1 address (주소는 주로 16진수로 표현됨)
  - **컴퓨터는 기억 공간을 관리할 때 1 byte 단위로 관리한다.**

### 8 bit = 1 byte 로 사용하는 이유

- 40 + 30의 연산에서 30과 40은 1bit에 저장가능한 값이 아니기 때문에 40과 30을 비트 단위의 값인 101000과 11110으로 변경하고 이 값들을 다시 비트 단위로 연산해야한다.

- 이런 불편함 때문에 연산 장치나 메모리는 기본 관리 단위를 비트가 아닌 8개의 비트를 그룹 지은 바이트(byte) 단위로 관리한다.<br>

- 1 byte = 8개의 비트로 구성되기 때문에 0-255 사이의 값을 저장할 수 있고, 2 byte는 16개의 비트로 구성되어 0-65535 사이의 값을 저장할 수 있다.

### 32 bit 시스템 (OS, CPU, App)
- OS가 32bit라는 것은 2의 32승(4 GB)만큼 메모리 공간(주소)을 가지고 수 있음을 의미한다.
- 컴퓨터 용량 단위는 1,024 byte (2^10)
- 2^32 = 4,294,967,296 byte 
- 4,294,967,296/1,024 = 4,194,304 KB
- 4,194,304/1,024 = 4,096 MB
- 4,096/1024 = 4 GB

다시 말해서, 32bit OS(CPU, App)란 것은 메모리를 통제할 수 있는 최대 범위가 4 GB라는 것<br>

> **P.S.** GB (기가바이트) > TB (테라바이트) > PB (페타바이트) > EB (에타바이트) > ZB (제타바이트) > YB (요타바이트) 순 <br>
64bit는 2^64 = 16 EB <br>

- OS가 32bit 인데 램을 8 GB 넣어도 운영체제가 4 GB만 통제할 수 있으니 나머지 4 GB는 사용하지 못한다.
- C언어에서 int 자료형으로 생각해보면 0~255까지의 숫자 하나를 1 byte에 저장.
<br><br>

## 16진수 

- 위에서 4 bit로 0~15까지 표현해보았는데, 10부터는 A로 표현하면 아래와 같다.
  - 0000 = 0
  - 0001 = 1
  - 0010 = 2
  - ...
  - 1001 = 9
  - ...
  - 1010 = A (10진수 10부터는 영어로 표현)
  - 1111 = F (10진수 16)

- 8 bit (1 byte)는 16진수로 표현하기 위해 잠시 4 bit + 4 bit 관점으로 볼 수 있다.
  - 예를 들어, 01000001은 4bit + 4bit로 나누면 0100 0001이다.
  - 위 0100 0001을 16진수로 나타내면 0x41 인데(0x는 헥사 코드로 16진수라는 것을 명시한 것 뿐)
  - 여기서, 0100 = 4 / 0001 = 1 이므로 0x41로 표현되는 것이다.
  - 다른 예로,
    - 0x73는 0111 0011 (앞 7 뒤 3)
    - 0xC3는 1100 0011 (앞 C 뒤 3)
  - 4bit + 4 bit도 8 bit이므로 1 byte를 의미한다.

**<u>4 bit는 16진수 한 자리 숫자이며, 16진수는 0 ~ F(10진수 15)까지를 한 자리에 쓴다.</u>**<br>
<br>

### 16진수, 10진수, 2진수 간의 진법 변환

- 위의 0x73과 0xC3을 10진수로 진법 변환하면,
  - 0x73는 0111 0011 (앞 7 뒤 3) -> 앞 7*16^1 + 뒤 3*16^0 = 115
  - 0xC3는 1100 0011 (앞 C 뒤 3) -> 앞 12*16^1 + 뒤 3*16^0 = 195
- 또는 2진수 관점에서 10진수로 변환하면,
  - 01110011 = 2^6+2^5+2^4+2^1+2^0 = 115
  - 11000011 = 2^7+2^6+2^1+2^0 = 195
<br><br>

## 디지털 회로 (AND, OR, XOR, Not)

- 본 글에서는 조합논리회로를 디지털 회로라고 부른다.
- 디지털회로는 **과거의 입력에 상관없이 현재의 입력 값에 의해 출력이 결정되는 회로**를 의미한다.
- 먼저 회로의 논리연산을 진리표로 표현하면 아래 그림과 같다.

<p align="center"><img src="/assets/images/logic_truth_table.png" width="1000px" height="595px"></p>
- 그림 출처: [https://siit.co/blog/how-logic-gates-work-or-and-xor-nor-nand-xnor-and-not/2918](https://siit.co/blog/how-logic-gates-work-or-and-xor-nor-nand-xnor-and-not/2918)
<br><br>

- 아래부터 설명할 반가산기와 전가산기에 대한 설명은 [대멀쌤 YouTube](https://youtu.be/F3vyljV4soo)에 쉽게 설명되어 있다.

### 반가산기(Half Adder)

- 그림 출처: [httpswoodforest.tistory.com122](httpswoodforest.tistory.com122)
<p align="center"><img src="/assets/images/half_adder.png" width="700px" height="320px"></p>

- 반가산기는 **1 bit 2개, 즉 2개의 이진수($A,B$)를 더하는 논리회로**이다.
- 반가산기는 **2개의 입력과 출력**으로 이루어진다.
- 입력(A, B): 1 bit가 0 or 1 (On or Off)인 경우
- 출력(S, C):
  - S = Sum 으로 A, B를 XOR 연산한 결과를 의미하며, 2진수 두 개의 합이다
    - A=0, B=0일 때 S = 0
    - A=1, B=0일 때 S = 1
    - A=0, B=1일 때 S = 1
    - A=1, B=1일 때 S = 0 이며, 자리올림 수(Carry) 발생
  - C = Carry 로 A, B를 AND 연산한 결과를 의미
    - A=1, B=1일 때만 C = 1

- 논리식으로 표현하면 아래와 같다.
  - $S=\bar{A}B+A\bar{B}=A \oplus B$
    - 위 논리식은 $S$ 가 1이 되는 경우를 나타내는 것
    - $\bar{A}$ 는 A=0일 때, $A$ 는 A=1일 때를 의미
    - $\bar{A}B+A\bar{B}$ 는 (A=1, B=0)인 경우와 (A=0, B=1)인 경우만 포함한다는 것을 의미
    - $\oplus$ 는 XOR 연산을 의미
  - $C = AB$
    - (A=1, B=1)인 경우에만 $C$ 가 1이 됨.
    - 이는 이진수의 합에서 자리올림이 발생한 경우를 나타냄.
<br><br>

### 전가산기(Full Adder)

- 그림 출처: [https://e-funny.tistory.com/entry/half-adder-full-adder](https://e-funny.tistory.com/entry/half-adder-full-adder)
<p align="center"><img src="/assets/images/full_adder.png" width="559px" height="364px"></p>
- 그림 출처: [https://www.javatpoint.com/verilog-full-adder](https://www.javatpoint.com/verilog-full-adder)
<p align="center"><img src="/assets/images/full_bool.png" width="450px" height="220px"></p>

- 전가산기는 **1 bit 2개와 자리올림 수(Carry) 1 bit를 고려하여 총 3개의 이진수($A, B, C_{in}$)로 만든 가산기**이다.
- 전가산기는 **입력 3개($A, B, C_{in}$), 출력 2개($C_{out}, S$)**로 이루어진다.
- 논리식으로 표현하면 아래와 같다.
  - $S=\bar{A}\bar{B}C_{in}+\bar{A}B\bar{C_{in}}+A\bar{B}\bar{C_{in}}+ABC_{in} = (AB+\bar{A}\bar{B})C_{in}+(\bar{A}B+A\bar{B})\bar{C_{in}} = \bar{(A \oplus B)}C_{in}+(A \oplus B)\bar{C_{in}} = A \oplus B \oplus C_{in}$
    - $S$ 가 1이 되는 경우의 수는 총 4가지($\bar{A}\bar{B}C_{in}+\bar{A}B\bar{C_{in}}+A\bar{B}\bar{C_{in}}+ABC_{in}$)이며, 수식을 정리하면 최종적으로 $A \oplus B \oplus C_{in}$ 가 된다는 것을 나타냄
    - $\bar{\oplus}$ 는 XNOR을 의미.
  - $C_{out}=A\bar{B}C_{in}+\bar{A}BC_{in}+AB= (A \oplus B)C_{in}+AB$
    - $C$ 가 1인 경우는 반가산기와 마찬가지로 $A, B, C_{in}$ 중 2개 이상의 bit가 1인 경우 즉, 자리올림이 발생하는 4개 경우이다.

- 전가산기는 아래 그림과 같이 **반가산기(XOR 1개+AND 1개) 2개와 OR 연산자 1개로 구성**된다.
<p align="center"><img src="/assets/images/img.png" width="800px" height="300px"></p>
- 그림 출처: [https://e-funny.tistory.com/entry/half-adder-full-adder](https://e-funny.tistory.com/entry/half-adder-full-adder)

- 가산기(Adder)를 이해하는 것이 중요한 이유는 **컴퓨터(CPU)는 더하기(+) 연산만으로 사칙연산이 가능**한데, 아래 그림의 4 bit 전가산기(병렬 가산기)와 같이 **병렬 구조**로 연결된 가산기를 통해 숫자의 모든 연산이 가능하고 이를 통해 정보를 처리하기 때문이다.
<p align="center"><img src="/assets/images/4bit_fulladder.png" width="505px" height="202px"></p>
- 그림 출처: [https://www.wikiwand.com/ko/%EA%B0%80%EC%82%B0%EA%B8%B0](https://www.wikiwand.com/ko/%EA%B0%80%EC%82%B0%EA%B8%B0)
<p align="center"><img src="/assets/images/4bit_adder.png" width="505px" height="202px"></p>
- 그림 출처: [http://cms3.koreatech.ac.kr/sites/yjjang/down/digi09/ch07.pdf](http://cms3.koreatech.ac.kr/sites/yjjang/down/digi09/ch07.pdf)
<br><br>

## 컴퓨터의 사칙연산

- 컴퓨터(CPU)는 가산기(+)만 있어도 되는 이유는 사칙연산이 더하기만으로 가능하기 때문이라고 했다. 
- 컴퓨터의 연산은 2진수의 연산이다.
- 컴퓨터가 가산기만으로 사칙연산을 하는 방법은 아래에서 설명한다.
<br>

### 덧셈
- 기본적으로 2진수의 덧셈은 10진수의 덧셈과 계산하는 방식이 같다.​

```
 1010   　　# 십진수 10​
+0110   　　# 십진수 6​
----------​
10000   　　# 십진수 16​
```
​<br>

### 뺄셈
- 컴퓨터 내부에서는 덧셈만 가능하기 때문에 **뺄셈은 보수를 이용해 덧셈으로 바꾼다**. ​<br>
- **컴퓨터는 2​의 보수를 사용한다.**
- 예) A - B는 B의 2의 보수를 구한 다음 덧셈 A + (B의 2의 보수)로 바꾸어 계산<br>

**보수란 무엇인가?**

- 컴퓨터는 N개의 비트를 이용해 2^N개의 정수만 표현할 수 있다. 
- 또한 정수는 음의 정수와 양의 정수로 나누어지기 때문에 +, - 기호 또한 전부 비트로 표현을 해주어야 한다. 
- 하지만 정확히 어떠한 방식으로 이를 표현하는지 알기 위해서는 **보수**의 개념을 이해하면 된다.
- **보수**란, <u>'두 수의 합이 진법의 밑수가 되게 하는 수'</u>를 말한다.
- 10진수에서, 4의 10의 보수는 6이고, 2의 10의 보수는 8이다.

▶ 1의 보수 : 2진수에서 0 -> 1, 1 -> 0로 바꾼다.<br>

  예시 ) 10은 2진수로 1010이며, 1010의 1의 보수는 0101<br>
​<br>
▶ 2의 보수 : 1의 보수에 1을 더한 값과 같다.​​​<br>

  예시 ) 2진수 1010에 대한 2의 보수를 구하려면 2진수 1010의 1의 보수 0101을 구한 다음 1을 더해(+0001) 0110을 얻는다.​

**2의 보수 뺼셈** : 2의 보수를 이용한 뺄셈은 빼는 수의 2의 보수를 구하여 더해준 뒤 다음 규칙을 따른다. 

(1) 덧셈한 결과, 최상위 비트에서 자리 올림이 생겼다면 자리올림을 제외한 나머지 부분이 연산 결과다

```
 111   　　# 십진수 7​
-110   　　# 십진수 6​
-----  　　# 보수의 덧셈으로 변환
 111   　　
+010   　　
-----  　　
1001   　　
-----  　　# 최상위 비트 제거
001   　　 # 십진수 1
```

  - 110의 2의 보수는 $010$
  - 자리올림이 발생. 최상위 비트를 지우므로 답은 $001$이다.

(2) 자리 올림이 생기지 않았다면 연산 결과의 2의 보수를 구한 후 - 부호를 붙인다.

```
 100   　　# 십진수 4
-110   　　# 십진수 6​
-----  　　# 보수의 덧셈으로 변환
 100   　　
+010   　　
-----  　　
 110   　　
-----  　　# 연산결과의 2의 보수 구하기
-010   　　# 십진수 -2
```

- $110$ 의 2의 보수는 $010$ 이고 - 부호를 붙이면 답은 $-010$ 또는 $1010$이다 (최상위 비트 1은 -부호를 의미).
​<br>​<br>

### 곱셈
- 곱셈은 덧셈와 같다.
- 예를 들어, 10 * 8은 10을 8번 더해주는 것과 같다.
- 그러나 긴 곱셈(long mulitplication)에서는 시프팅이 일어난다.
​<br>​<br>

### 나눗셈
- 나눗셈은 뺄셈과 같다.
- 예를 들어, 10/3는 10에 3을 3번 빼주면 되고, 나머지 1을 남긴다.


