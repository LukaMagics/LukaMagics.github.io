---
title: "[Java] 클래스와 메소드, static, public"

categories:
  - java
tags:
  - [java, 기초, 클래스, 메소드, static, public]

toc: true
toc_sticky: true
comments: true
use_math: true
date: 2022-06-12
last_modified_at: 2022-06-13
---

📌 **작성자 개발 환경** <br>
**OS** : Windows <br>
**Language** : Java<br>
**Tool** : Visual Studio Code<br>
{: .notice--primary}

# 메소드 생성

```java

```

# 클래스 생성

## 필드와 메소드

- 필드(Fields)와 메소드(Methods)는 각각 클래스의 정보 및 동작을 정의하는 구성요소다.
    - 필드: 객체의 정보(상태)
    - 메소드: 객체의 동작(기능)

```java
class Person {
  // 필드(fields)
  String name; // 
  String age; // 

  // 메소드(methods)
  generatePerson(String name) {
    this.name = name;
    count++;
  }
}
```

## static(정적) 키워드

- 참고글
    - [https://mangkyu.tistory.com/47](https://mangkyu.tistory.com/47)
    - [https://vaert.tistory.com/101](https://vaert.tistory.com/101)
    - [https://dev-coco.tistory.com/23](https://dev-coco.tistory.com/23)

- 필드(변수)와 메소드에는 static 키워드를 사용할 수 있다.
- 필드 단에서 **변수**에 `static` 키워드를 사용하면 **클래스 변수(static 변수, static field)**가 된다.
    - 이는 **객체 외부와 공유 가능한 변수**이며,
    - 메모리에 고정적으로 할당되어, 프로그램이 종료될 때 해제되는 변수이다.
    - 클래스 변수가 아닌(static이 붙지 않은) 변수를 인스턴스 변수라고 한다
- 메소드에 대해 `static` 키워드를 사용하면 **Static 메소드, 정적 메소드, 유틸리티 메소드**라고 불린다.
    - 해당 메소드는 **인스턴스 생성 없이 호출이 가능하다**. (인스턴스에서도 호출이 가능하나 지양된다)
    - static 메소드는 **인스턴스 변수**에 접근이 불가능하고 클래스 변수(static 변수)에만 접근 가능하다(반대로, 인스턴스 변수 및 메소드에서는 static 변수 사용이 가능).

```java
public class Test {
    
    // 1
    static void m() {
        int i = 0
    }

    // 2
    static int i;

    static void m() {
        i = 0;
    }

    // 3
    static int i;

    static void m() {
        int i = 0;
    }

    public static void main(String[] args) {
        for (int i = 0; i < 5; i++) {
            m();
            System.out.println(i); // 0 1 2 3 4 or 0 0 0 0 ...
        }
    }
}
```

- 위 코드에서 `m()` 메소드를 3가지 방식으로 정의해보았다.
    - 1번: 변수 i는 `m()` 메소드 내부의 변수로 `main()`에 영향 X
    - 2번: 변수 i는 클래스 변수(전역 변수)로 `main()`에 영향을 주어 무한 loop에 빠진다
    - 3번: `m()`의 변수 i는 메소드 내에서 선언되어(지역변수) `main()`의 i와 이름은 같지만 다른 변수로 main에 영향 X 

- 아래는 클래스 변수와 static 메소드 사용 예시다.

```java
class Person {
    // 필드(fields)
    String name; // 인스턴스 변수: 객체 내부의 변수
    String age;
    static int count; // 클래스 변수: 객체 외부와 공유 가능한 변수
  
    // 메소드(methods)
    void setPerson(String name, String age) {
      this.name = name;
      this.age = age;
      count++;
    }
    
    // static 메소드(methods)
    static void countPerson() {
      System.out.println(count);
    }
  }

class Method {
    public static void main(String[] args) {
        
        Person p1 = new Person();   // instance 생성
        p1.setPerson("john", "28");
        System.out.println("Name: "+p1.name+"\nAge: "+p1.age);  // 인스턴스 변수 출력

        Person p2 = new Person();   // instance 생성
        p2.setPerson("mark", "32");
        System.out.println("Name: "+p2.name+"\nAge: "+p2.age);  // 인스턴스 변수 출력

        // static 메소드 호출: 클래스 변수 출력
        Person.countPerson(); // static 메소드가 아닌 경우 "p2.countPerson();"
    }
}
```

- **static 사용지침**
    - 클래스의 변수 중 모든 인스턴스에 공통된 값을 유지해야하는 것이 있는지 보고 있다면 static을 붙여준다.
    - 작성한 메소드 중 인스턴스 변수를 사용하지 않는 메소드에 대해서 static을 붙일 것을 고려한다(그러나 static 메소드의 사용은 지양된다).
- **참고사항**
    - 일반적으로 인스턴스변수와 관련된 작업을 하는 메소드는 인스턴스메소드 (static X)이고,
    - static변수(클래스변수)와 관련된 작업을 하는 메소드는 클래스메소드 (static O)이다.

## 지역변수, 전역변수(인스턴스 변수), Static 변수(클래스 변수)

- 지역변수: 메소드 영역의 변수
```java
public class example {
    public static void main(String[] args) {
        int i = 0; // 지역변수
        System.out.println(i);
    }
}
```

- 전역변수: 클래스 영역의 Non Static 변수 (인스턴스변수)
```java
public class C1 {
    int i = 0; // 전역변수(인스턴스변수)
    
    public void plus1() {
        this.i += 1;
    }

    public static void main(String[] args) {
        C1 inst = new C1();
        System.out.println(inst.i);
        inst.plus1();
        System.out.println(inst.i);
    }
}
```

- Static 변수: 클래스 영역의 Static 변수 (클래스 변수)
```java
public class C1 {
    static int i = 0; // Static 변수(클래스 변수)
    
    public void plus1() {
        i += 1; 
    }
    public static void main(String[] args) {
        System.out.println(i); // 0
        i = i+1;
        System.out.println(i); // 1
        
        C1 inst = new C1();
        System.out.println(i); // 1
        inst.plus1();
        System.out.println(i); // 2
    } 
}
```