---
title: "CPU가 작동하는 원리"

categories:
  - cs
tags:
  - [bit, byte, 2진수, 16진수, 가산기]

toc: true
toc_sticky: true
comments: true
use_math: true
date: 2022-04-21
last_modified_at: 2022-04-21
---

📌 **작성자 개발 환경** <br>
**OS** : Windows 10 <br>
**Language** : None<br>
**Tool** : None<br>
{: .notice--primary}

# CPU가 작동하는 원리

- 컴퓨터의 구조에서 가장 중요한 것은 **CPU**라고 할 수 있다.
- 컴퓨터 내 모든 정보는 숫자로만 이루어져있으며, **CPU**를 통해 숫자 정보를 연산한다.
- 또한 CPU의 **연산 기능(계산기)**이 컴퓨터의 모든 것을 구현한다고 말할 수 있다.
- CPU의 연산을 간단한 수준으로 이해하기 위해 아래에 대한 학습이 필요하다.
  1. bit, byte, 2진수, 16진수, 진법 변환 등
  2. 반가산기, 전가산기 등 디지털 회로
<br><br>

## bit (2진수)

- 1bit는 **On/Off가 가능한 1개의 스위치**를 의미한다.
- bit는 binary digit(2진수)의 줄인말
- 컴퓨터는 주로 2진수에 의해 동작하는데, 우리가 쓰는 10진수를 쓰지 않는 이유는 컴퓨터의 회로가 너무 복잡해지기 때문에 2개의 신호만 받아들이게 설계되었다.
- 4 bit는 4개의 On/Off 스위치를 의미하며, 구현가능한 모든 경우의 수는 16가지이다.
  - 4 bit = 2^4 = 16
  - 2진수 4개(4 bit)로 표현할 수 있는 10진수의 양수로 보면 0~15까지
  - 0000 = 0
  - 0001 = $2^0$ = 1
  - 0010 = $2^1$ = 2
  - 0011 = $2^1 + 2^0$ = 3<br>
     ...
  - 1111 = $2^1 + 2^0$ 15

- 위와 같이 2진수를 주로 사용되는 10진수로 표현하는 등 다른 진수로 표현하는 것을 **진법 변환**이라 한다.


### bit와 byte

- byte의 정의
> The byte was the number of bits used to encode a single character of text in a computer (i.e. 8 bits per character)
- 일반적으로 8 bit(8개 스위치)를 하나로 묶어 1 byte라 한다.

- 메모리(Memory)
  - 컴퓨터의 **자료(또는 정보)**는 **숫자**를 의미한다
  - 컴퓨터에서는 정보를 어딘가에 보관해야하고, 그곳이 **메모리(Memory)**다.
  - 메모리 안에 보관되어 있는 정보를 넣거나 빼는 등 관리를 통해 정보가 움직인다.
  - 컴퓨터는 0️⃣1️⃣2️⃣3️⃣4️⃣5️⃣의 형태처럼 메모리 내 각 공간에 번호를 붙여 자료(정보)를 관리
  - 각 공간에 저장할 수 있는 기억 공간의 크기는 **1 byte (8 bit)**<br>
  - 메모리에서 하나의 주소(1 byte, 0️⃣)에 저장할 수 있는 정보는 영문 1글자(예: hello는 5byte), 한글은 1글자에 2 byte가 필요하다.
  - 0️⃣1️⃣2️⃣3️⃣4️⃣5️⃣... 각 공간의 위치를 나타내는 번호를 **주소(address)**라고 하며, 1 byte = 1 address (주소는 주로 16진수로 표현됨)
  - **컴퓨터는 기억 공간을 관리할 때 1 byte 단위로 관리한다.**

### 8 bit = 1 byte 로 사용하는 이유

- 40 + 30의 연산에서 30과 40은 1bit에 저장가능한 값이 아니기 때문에 40과 30을 비트 단위의 값인 101000과 11110으로 변경하고 이 값들을 다시 비트 단위로 연산해야한다.

- 이런 불편함 때문에 연산 장치나 메모리는 기본 관리 단위를 비트가 아닌 8개의 비트를 그룹 지은 바이트(byte) 단위로 관리한다.<br>

- 1 byte = 8개의 비트로 구성되기 때문에 0-255 사이의 값을 저장할 수 있고, 2 byte는 16개의 비트로 구성되어 0-65535 사이의 값을 저장할 수 있다.

### 32 bit 시스템 (OS, CPU, App)
- OS가 32bit라는 것은 2의 32승(4 GB)만큼 메모리 공간(주소)을 가지고 수 있음을 의미한다.
- 컴퓨터 용량 단위는 1,024 byte (2^10)
- 2^32 = 4,294,967,296 byte 
- 4,294,967,296/1,024 = 4,194,304 KB
- 4,194,304/1,024 = 4,096 MB
- 4,096/1024 = 4 GB

다시 말해서, 32bit OS(CPU, App)란 것은 메모리를 통제할 수 있는 최대 범위가 4 GB라는 것<br>

> **P.S.** GB (기가바이트) > TB (테라바이트) > PB (페타바이트) > EB (에타바이트) > ZB (제타바이트) > YB (요타바이트) 순 <br>
64bit는 2^64 = 16 EB <br>

- OS가 32bit 인데 램을 8 GB 넣어도 운영체제가 4 GB만 통제할 수 있으니 나머지 4 GB는 사용하지 못한다.
- C언어에서 int 자료형으로 생각해보면 0~255까지의 숫자 하나를 1 byte에 저장.
<br><br>

## 16진수 

- 위에서 4 bit로 0~15까지 표현해보았는데, 10부터는 A로 표현하면 아래와 같다.
  - 0000 = 0
  - 0001 = 1
  - 0010 = 2
  - ...
  - 1001 = 9
  - ...
  - 1010 = A (10진수 10부터는 영어로 표현)
  - 1111 = F (10진수 16)

- 8 bit (1 byte)는 16진수로 표현하기 위해 잠시 4 bit + 4 bit 관점으로 볼 수 있다.
  - 예를 들어, 01000001은 4bit + 4bit로 나누면 0100 0001이다.
  - 위 0100 0001을 16진수로 나타내면 0x41 인데(0x는 헥사 코드로 16진수라는 것을 명시한 것 뿐)
  - 여기서, 0100 = 4 / 0001 = 1 이므로 0x41로 표현되는 것이다.
  - 다른 예로,
    - 0x73는 0111 0011 (앞 7 뒤 3)
    - 0xC3는 1100 0011 (앞 C 뒤 3)
  - 4bit + 4 bit도 8 bit이므로 1 byte를 의미한다.

**<u>4 bit는 16진수 한 자리 숫자이며, 16진수는 0 ~ F(10진수 15)까지를 한 자리에 쓴다.</u>**<br>
<br>

### 16진수, 10진수, 2진수 간의 진법 변환

- 위의 0x73과 0xC3을 10진수로 진법 변환하면,
  - 0x73는 0111 0011 (앞 7 뒤 3) -> 앞 7*16^1 + 뒤 3*16^0 = 115
  - 0xC3는 1100 0011 (앞 C 뒤 3) -> 앞 12*16^1 + 뒤 3*16^0 = 195
- 또는 2진수 관점에서 10진수로 변환하면,
  - 01110011 = 2^6+2^5+2^4+2^1+2^0 = 115
  - 11000011 = 2^7+2^6+2^1+2^0 = 195
<br><br>

## 조합논리회로 (AND, OR, XOR, Not)

- 조합논리회로는 **과거의 입력에 상관없이 현재의 입력 값에 의해 출력이 결정되는 회로**를 의미한다.
- 먼저 회로의 논리연산을 진리표로 표현하면 아래 그림과 같다.

<p align="center"><img src="/assets/images/logic_truth_table.png" width="1000px" height="595px"></p>
- 그림 출처: [https://siit.co/blog/how-logic-gates-work-or-and-xor-nor-nand-xnor-and-not/2918](https://siit.co/blog/how-logic-gates-work-or-and-xor-nor-nand-xnor-and-not/2918)
<br><br>

- 조합논리회로의 종류에는 반가산기, 전가산기, 병렬가산기, 반가산기, 전감산기, 인코더, 디코더, 멀티플렉서, 디멀티플렉서, 연산기, 비교기 등이 있다.
- 본 글에서는 가장 중요한 **반가산기, 전가산기, 병렬가산기**에 대해 정리하였다.
- 반가산기와 전가산기에 대한 설명은 [대멀쌤 YouTube](https://youtu.be/F3vyljV4soo)에 쉽게 설명되어 있다.

### 반가산기(Half Adder)

- 그림 출처: [httpswoodforest.tistory.com122](httpswoodforest.tistory.com122)
<p align="center"><img src="/assets/images/half_adder.png" width="700px" height="320px"></p>

- 반가산기는 **1 bit 2개, 즉 2개의 이진수($A,B$)를 더하는 논리회로**이다.
- 반가산기는 **2개의 입력과 출력**으로 이루어진다.
- 입력(A, B): 1 bit가 0 or 1 (On or Off)인 경우
- 출력(S, C):
  - S = Sum 으로 A, B를 XOR 연산한 결과를 의미하며, 2진수 두 개의 합이다
    - A=0, B=0일 때 S = 0
    - A=1, B=0일 때 S = 1
    - A=0, B=1일 때 S = 1
    - A=1, B=1일 때 S = 0 이며, 자리올림 수(Carry) 발생
  - C = Carry 로 A, B를 AND 연산한 결과를 의미
    - A=1, B=1일 때만 C = 1

- 논리식으로 표현하면 아래와 같다.
  - $S=\bar{A}B+A\bar{B}=A \oplus B$
    - 위 논리식은 $S$ 가 1이 되는 경우를 나타내는 것
    - $\bar{A}$ 는 A=0일 때, $A$ 는 A=1일 때를 의미
    - $\bar{A}B+A\bar{B}$ 는 (A=1, B=0)인 경우와 (A=0, B=1)인 경우만 포함한다는 것을 의미
    - $\oplus$ 는 XOR 연산을 의미
  - $C = AB$
    - (A=1, B=1)인 경우에만 $C$ 가 1이 됨.
    - 이는 이진수의 합에서 자리올림이 발생한 경우를 나타냄.
<br><br>

### 전가산기(Full Adder)

- 그림 출처: [https://e-funny.tistory.com/entry/half-adder-full-adder](https://e-funny.tistory.com/entry/half-adder-full-adder)
<p align="center"><img src="/assets/images/full_adder.png" width="559px" height="364px"></p>
- 그림 출처: [https://www.javatpoint.com/verilog-full-adder](https://www.javatpoint.com/verilog-full-adder)
<p align="center"><img src="/assets/images/full_bool.png" width="450px" height="220px"></p>

- 전가산기는 **1 bit 2개와 자리올림 수(Carry) 1 bit를 고려하여 총 3개의 이진수($A, B, C_{in}$)로 만든 가산기**이다.
- 전가산기는 **입력 3개($A, B, C_{in}$), 출력 2개($C_{out}, S$)**로 이루어진다.
- 논리식으로 표현하면 아래와 같다.
  - $S=\bar{A}\bar{B}C_{in}+\bar{A}B\bar{C_{in}}+A\bar{B}\bar{C_{in}}+ABC_{in} = (AB+\bar{A}\bar{B})C_{in}+(\bar{A}B+A\bar{B})\bar{C_{in}} = \bar{(A \oplus B)}C_{in}+(A \oplus B)\bar{C_{in}} = A \oplus B \oplus C_{in}$
    - $S$ 가 1이 되는 경우의 수는 총 4가지($\bar{A}\bar{B}C_{in}+\bar{A}B\bar{C_{in}}+A\bar{B}\bar{C_{in}}+ABC_{in}$)이며, 수식을 정리하면 최종적으로 $A \oplus B \oplus C_{in}$ 가 된다는 것을 나타냄
    - $\bar{\oplus}$ 는 XNOR을 의미.
  - $C_{out}=A\bar{B}C_{in}+\bar{A}BC_{in}+AB= (A \oplus B)C_{in}+AB$
    - $C$ 가 1인 경우는 반가산기와 마찬가지로 $A, B, C_{in}$ 중 2개 이상의 bit가 1인 경우 즉, 자리올림이 발생하는 4개 경우이다.

- 전가산기는 아래 그림과 같이 **반가산기(XOR 1개+AND 1개) 2개와 OR 연산자 1개로 구성**된다.
<p align="center"><img src="/assets/images/img.png" width="800px" height="300px"></p>
- 그림 출처: [https://e-funny.tistory.com/entry/half-adder-full-adder](https://e-funny.tistory.com/entry/half-adder-full-adder)

- 가산기(Adder)를 이해하는 것이 중요한 이유는 **컴퓨터(CPU)는 더하기(+) 연산만으로 사칙연산이 가능**한데, 아래 그림의 4 bit 전가산기(병렬 가산기)와 같이 **병렬 구조**로 연결된 가산기를 통해 숫자의 모든 연산이 가능하고 이를 통해 정보를 처리할 수 있기 때문이다.

<p align="center"><img src="/assets/images/4bit_fulladder.png" width="505px" height="202px"></p>
- 그림 출처: [https://www.wikiwand.com/ko/%EA%B0%80%EC%82%B0%EA%B8%B0](https://www.wikiwand.com/ko/%EA%B0%80%EC%82%B0%EA%B8%B0)
<p align="center"><img src="/assets/images/4bit_adder.jpg" width="655px" height="185px"></p>
- 그림 출처: [http://cms3.koreatech.ac.kr/sites/yjjang/down/digi09/ch07.pdf](http://cms3.koreatech.ac.kr/sites/yjjang/down/digi09/ch07.pdf)
<br><br>

## 컴퓨터의 사칙연산

- 컴퓨터(CPU)는 가산기(+)만 있어도 되는 이유는 사칙연산이 더하기만으로 가능하기 때문이라고 했다. 
- 컴퓨터의 연산은 2진수의 연산이다.
- 그리고 덧셈으로 구현되는 사칙연산의 방식은 자료형마다 다양하다.
- 우선 컴퓨터가 가산기만으로 사칙연산을 하는 방법을 정수 자료형에 기초하여 아래에 설명하였다.
<br>

### 덧셈
- 기본적으로 2진수의 덧셈은 10진수의 덧셈과 계산하는 방식이 같다.​

```
 1010   　　# 십진수 10​
+0110   　　# 십진수 6​
----------​
10000   　　# 십진수 16​
```
​<br>

### 뺄셈
- 컴퓨터 내부에서는 덧셈만 가능하기 때문에 **뺄셈은 보수를 이용해 덧셈으로 바꾼다**. ​<br>
- **컴퓨터는 2​의 보수를 사용한다.**
- 예) A - B는 B의 2의 보수를 구한 다음 덧셈 A + (B의 2의 보수)로 바꾸어 계산<br>

**보수란 무엇인가?**

- 컴퓨터는 N개의 비트를 이용해 2^N개의 정수만 표현할 수 있다. 
- 또한 정수는 음의 정수와 양의 정수로 나누어지기 때문에 +, - 기호 또한 전부 비트로 표현을 해주어야 한다. 
- 하지만 정확히 어떠한 방식으로 이를 표현하는지 알기 위해서는 **보수**의 개념을 이해하면 된다.
- **보수(Complement)**란, <u>'보충해주는 수'</u>를 말한다.
- 10진수에서, 4의 10의 보수는 6이고, 75의 10의 보수는 24이다.
- 4가 10이 되기 위해선 6을 보충해줘야하고, 75가 100이 되기 위해선 25를 보충해줘야해서 보수라고 이해하면 좋다.
- 다른 예로 9의 보수로 보면, 4에 대한 9의 보수는 5, 75에 대한 9의 보수는 99를 만드는 24이다. 여기서 재밌는 사실은 10의 보수와 9의 보수는 1 만큼 차이가 난다. 즉, 특정 수에 대한 N의 보수와 N-1 보수의 차이는 1이다.
  - 이러한 사실을 통해 아래 1의 보수와 2의 보수의 관계를 이해하자.
- 참고로, 1의 보수와 2의 보수는 십진수가 아닌 이진수에 대해서 적용된다.

▶ **1의 보수(one's complement)** : 1의 보수를 만드는 방법은 2진수에서 0 -> 1, 1 -> 0로 바꾸면 된다. 이진수 1001 -> 이진수 1111이 되기 위해선 0110을 더해주면 되므로 간단히 구할 수 있다.<br>

  예시 ) 2진수 1010의 1의 보수는 0101 <br>
​<br>
▶ **2의 보수(two's complement)** : 1의 보수에 1을 더한 값과 같다. 바꿔 말하면, 이진수 1001 -> 이진수 1111 + 0001= 10000으로 만들기 위해선 0111을 더해줘야한다.​​​<br>

  예시 ) 2진수 1010에 대한 2의 보수는 1010의 1의 보수 0101 + 0001하여 0110 이다.​

**2의 보수 뺼셈** : 2의 보수를 이용한 뺄셈은 빼는 수의 2의 보수를 구하여 더해준 뒤 다음 규칙을 따른다. 

(1) 덧셈한 결과, 최상위 비트에서 자리 올림이 생겼다면 자리올림을 제외한 나머지 부분이 연산 결과다

```
 111   　　# 십진수 7​
-110   　　# 십진수 6​
-----  　　# 보수의 덧셈으로 변환
 111   　　
+010   　　
-----  　　
1001   　　
-----  　　# 최상위 비트 제거
001   　　 # 십진수 1
```

  - 110의 2의 보수는 $010$
  - 자리올림이 발생. 최상위 비트를 지우므로 답은 $001$이다.

(2) 자리 올림이 생기지 않았다면 연산 결과의 2의 보수를 구한 후 - 부호를 붙인다.

```
 100   　　# 십진수 4
-110   　　# 십진수 6​
-----  　　# 보수의 덧셈으로 변환
 100   　　
+010   　　
-----  　　
 110   　　
-----  　　# 연산결과의 2의 보수 구하기
-010   　　# 십진수 -2
```

- $110$ 의 2의 보수는 $010$ 이고 - 부호를 붙이면 답은 $-010$ 또는 $1010$이다 (최상위 비트 1은 -부호를 의미).
​<br>​<br>

### 곱셈
- 곱셈은 덧셈으로 해결할 수 있다.
- 예를 들어, 10 * 8은 10을 8번 더해주는 것과 같다.
- 그러나 1298654825 * 85324154 같은 경우 매우 많이 반복되는 덧셈은 비효율적인 방식이다.
- 이런 경우 이진수 긴 곱셈(Binary long mulitplication) 방식을 이용할 수 있다.
- Binary long mulitplication은 아래 예시와 같이 우리가 학창 시절 배운 십진수 곱에서 partial product 방식과 비슷하다.

```
     123
   x 456
   =====
     738  (123 x 6)
    615   (123 x 5, 한 칸 shift)
 + 492    (123 x 4, 두 칸 shift)
   =====
   56088
```

- 이 방식을 이진수 곱에 적용시키면,

```
       1011   (십진수 11)
     x 1110   (십진수 14)
     ======
       0000   (1011 x 0)
      1011    (1011 x 1, 한 칸 shift)
     1011     (1011 x 1, 두 칸 shift)
  + 1011      (1011 x 1, 세 칸 shift)
  =========
   10011010   (십진수 154)
```

- CPU의 메모리인 레지스터는 위 예시에서 부분합의 결과인 0000 + 1011,  등을 저장하고, 중간에 서로 더해진 값 또한 저장한다.
- 이 방식은 기억하기 위한 곱셈표가 없기 때문에 십진법보다 훨씬 간단하다: 단지 Shift하고 더한다.
- 이 방법은 수학적으로 정확하다. 또한 작은 CPU가 특수 회로가 아닌 산술 논리 유닛의 시프트와 추가 기능을 사용하여 곱셈을 수행할 수 있다는 장점이 있다.
- 그러나 이 방법도 많은 중간 덧셈이 수반되기 때문에 느리다.
- 두 번째 문제는 부호를 처리해야 한다는 점이다. 현대의 컴퓨터는 숫자 자체에 숫자의 부호를 포함하는데, 보통 2의 보수 표현에 포함된다. 
- 이것은 곱셈 과정을 2의 보수를 처리하도록 강요하고, 이는 연산 과정을 조금 더 복잡하게 만든다.
- 그래서 실질적으로 현재의 CPU에서 이러한 곱셈을 하고 있지 않다. 적은 공간을 차지하는 shift 레지스터 같은 것을 이용해서 곱셈을 한다.
​<br>​<br>

### 나눗셈
- 나눗셈도 마찬가지로 뺄셈(보수의 덧셈)을 여러번 수행하면 구현할 수 있다.
- 예를 들어, 10/3는 10에 3을 3번 빼고, 나머지 1을 남기면 된다.
- 이러한 방식이 Slow Division이고, 곱셈과 마찬가지로 반복되는 뺼셈은 비효율적이고 느리다.