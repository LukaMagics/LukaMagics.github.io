---
title: "[C] 자료형_Chapter2"

categories:
  - cpp
tags:
  - [C언어, 자료형, bit, byte]

toc: true
toc_sticky: true
comments: true
date: 2022-04-08
last_modified_at: 2022-04-08
---

📌 **작성자 개발 환경** <br>
**OS** : Windows 10 <br>
**Language** : C<br>
**Tool** : Visual Studio Code<br>
{: .notice--primary}

자료형을 온전히 이해하기 위해선 **<u>bit, 메모리 공간, byte</u>**에 대해 알고 있어야한다. 

- 컴퓨터는 전자식 계산기로 1 or 0 / On or Off 의 개념만 존재한다.
- 전류가 흐르는 스위치를 생각했을 때, 스위치는 On/Off의 기능만을 가지고 있다.<br>
<br>

# bit란 무엇인가?
- 1bit는 On/Off 가능한 1개의 스위치를 의미한다.
- bit는 binary digit(2진수)의 줄인말
- 4 bit는 4개의 스위치를 On/Off 하는 모든 경우의 수를 의미
  - 4 bit = 2^4 = 16
  - 2진수 4개(4 bit)로 표현할 수 있는 10진수는 0~15
  - 0000 = 0
  - 0001 = 1
  - 0010 = 2
  - 0011 = 3<br>
     ...
  - 1111 = 15
<br><br>

# byte란 무엇인가?
<br>

- byte의 정의
> The byte was the number of bits used to encode a single character of text in a computer (i.e. 8 bits per character)

- **자료**는 **숫자**를 의미 (자료는 또한 정보)<br>
- 컴퓨터에서는 정보를 어딘가에 보관해야하고, 그곳이 **메모리(Memory)**다<br>
- 메모리 안에 보관되어 있는 정보를 넣거나 빼는 등 관리가 필요함.<br>
- 메모리는 0️⃣1️⃣2️⃣3️⃣4️⃣5️⃣ 형태처럼 메모리 내 각 공간에 번호를 붙여 자료(정보)를 관리<br>
- 각 공간에 저장할 수 있는 기억 공간의 크기는 **1 byte**<br>
- 0️⃣1️⃣2️⃣3️⃣4️⃣5️⃣... 각 공간의 위치를 나타내는 번호를 **주소(address)**라고 하며, 1 byte = 1 address (주소는 16진수로 표현)<br>

메모리에서 하나의 주소(1 byte, 0️⃣)에 저장할 수 있는 정보는 보통 영문 1글자<br>
**일반적으로 1 byte는 8 bit로 그룹지어 사용됨.**
<br><br>

# 8 bit = 1 byte 로 사용하는 이유
<br>
40 + 30의 연산에서 30과 40은 1bit에 저장가능한 값이 아니기 때문에 40과 30을 비트 단위의 값인 101000과 11110으로 변경하고 이 값들을 다시 비트 단위로 연산해야함.

그래서 이런 불편함 때문에 연산 장치나 메모리는 기본 관리 단위를 비트가 아닌 8개의 비트를 그룹 지은 바이트(byte) 단위로 관리함.<br>

1 byte = 8개의 비트로 구성되기 때문에 0-255 사이의 값을 저장할 수 있고,<br>

2 byte는 16개의 비트로 구성되어 0-65535 사이의 값을 저장할 수 있다.
<br>

# 32 bit 시스템 (OS, CPU, App)
- OS가 32bit라는 것은 2의 32승(4 GB)만큼 메모리 공간(주소)을 가지고 수 있음을 의미한다.
- 컴퓨터 용량 단위는 1,024 byte (2^10)
- 2^32 = 4,294,967,296 byte 
- 4,294,967,296/1,024 = 4,194,304 KB
- 4,194,304/1,024 = 4,096 MB
- 4,096/1024 = 4 GB

다시 말해서, 32bit OS(CPU, App)이란 것은 메모리를 통제할 수 있는 최대 범위가 4 GB라는 것<br>

> **P.S.** GB (기가바이트) > TB (테라바이트) > PB (페타바이트) > EB (에타바이트) > ZB (제타바이트) > YB (요타바이트) 순 <br>
64bit는 2^64 = 16 EB <br>

OS가 32bit 인데 램을 8 GB 넣어도 운영체제가 4 GB만 통제할 수 있으니 나머지 4 GB는 사용하지 못함<br>

int 자료형으로 생각해보면 0~255까지의 숫자 하나(8 bit)를 1 byte에 저장.<br>

문자열도 영어 문자 하나가 1 byte (예: hello는 5byte).<br>

**❓ 즉, 32bit OS에서는 4,294,967,296개의 영어 문자를 일시적으로 저장할 수 있는 것인가?**
<br>

1 byte = 8bit 일 때(정수 0~255까지 저장),
IP주소 192.168.0.1는 "8bit.8bit.8bit.8bit => 32bit"
<br>
<br>

# 변수와 상수

- **상수**: 확정된 값
- **변수**: 아직 확정되지 않은 값

C언어에서 **변수는 메모리**라고 기억하면 좋다.<br>
변수는 메모리로 구현되며, 메모리는 주소를 가진다.<br>
<br>

# 자료형

- 자료형이란 **일정 길이의 메모리에 저장된 자료(데이터)를 해석하는 방법이다.**

<br>

## int형

<br>정수(int)부터는 보수와 보수를 이용한 사칙연산을 알고 공부해야 한다. <br>

출처: [https://ndb796.tistory.com/4](https://ndb796.tistory.com/4)


### 보수의 개념

- 컴퓨터는 N개의 비트를 이용해 2^N개의 정수만 표현할 수 있다. 
- 또한 정수는 음의 정수와 양의 정수로 나누어지기 때문에 +, - 기호 또한 전부 비트로 표현을 해주어야 한다. 
- 하지만 정확히 어떠한 방식으로 이를 표현하는지 알기 위해서는 **보수**의 개념을 이해하면 된다.

- **보수**란, <u>'두 수의 합이 진법의 밑수(N)가 되게 하는 수'</u>를 말한다.
- 예를 들어 10진수 4의 10의 보수는 6이고, 10진수 2의 10의 보수는 8이다.
- 컴퓨터 내부에서는 사칙연산을 할 때 덧셈을 담당하는 가산기(Adder)만 이용하기 때문에 뺄셈은 덧셈으로 형식을 변환하여 계산해야 한다.
- 즉 컴퓨터 내부에서는 A - B를 계산할 때 B의 보수(-B)를 구한 다음 A + (-B)로 계산하는 것.<br>
<br>

▶ 1의 보수 : 각 자릿수의 값이 모두 1인 수에서 주어진 2진수를 빼면 1의 보수를 얻을 수 있다. 쉽게 말해 0 -> 1, 1 -> 0 바꾼다<br>

> 예시 ) 10은 2진수로 1010. 1010의 1의 보수는 0101<br>

​<br>
▶ 2의 보수 : 1의 보수에 1을 더한 값과 같다.​​​<br>

> 예시 ) 2진수 1010에 대한 2의 보수를 구하려면 2진수 1010의 1의 보수 0101을 구한 다음 1을 더해(+0001) 0110을 얻는다.​
<br>

**컴퓨터는 2​의 보수를 사용한다.**
<br>

### 컴퓨터의 사칙연산​<br>

​▶ **덧셈** : 기본적으로 2진수의 덧셈은 10진수의 덧셈과 계산하는 방식이 같다.​<br>
```
 1010   # 10
+0110   # 6
-----
10000   # 16
```
​<br>
▶ **뺄셈** : 컴퓨터 내부에서는 덧셈만 가능하기 때문에 뺄셈은 보수를 이용해 덧셈으로 바꾼다. ​<br>

예시 ) 뺄셈 A - B는 B의 보수를 구한 다음 덧셈 A + (B의 보수)로 바꾸어 계산<br>

- **1의 보수 뺄셈** : 1의 보수를 이용한 뺄셈은 빼는 수의 1의 보수를 구한 다음 더하고 아래 규칙에 따른다.

1. 덧셈한 결과가 최상위 비트에서 자리올림이 생겼다면 최하위 비트에 1을 더한다.<br>

> 예시 ) ​111(2) - 110(2) = 111(2) + 001(2) = 1000(2)에서 최상위 비트를 지우고 1을 더하므로 답은 1(2)다.<br>

2. 자리올림이 생기지 않았다면 연산 결과에 대해 1의 보수를 구한 후 - 부호를 붙인다.<br>

> 예시 ) 100(2) - 110(2) = ​100(2) + 001(2) = 101(2)에서 다시 1의 보수를 취하므로 답은 010(2).<br>

- **2의 보수 뺼셈** : 2의 보수를 이용한 뺄셈은 빼는 수의 2의 보수를 구한 다음 다음 규칠을 따른다. 

1. 덧셈한 결과가 최상위 비트에서 자리 올림이 생겼다면 자리올림을 제외한 나머지 부분이 연산 결과다

> 예시 ) 111(2) - 110(2) = 111(2) + 010(2) = 1001(2)에서 최상위 비트를 지우므로 답은 1(2)입니다.

2. 자리 올림이 생기지 않았다면 연산 결과의 2의 보수를 구한 후 - 부호를 붙인다.

> 예시 ) 1​00(2) - 110(2) = 100(2) + 010(2) = 110(2). 110(2)의 2의 보수는 010이고 - 부호를 붙이면 답은 -010(2) 또는 1010이다 (최상위 비트 1은 -부호를 의미).

- 바로 위 예시는 4 - 6 = -2 을 구한 것인데, <br>
- 여기서 -2는 1010으로 부호가 없다고 가정하면 10 (2^3+2^1)으로 해석할 것이고, 부호가 있다면 -2로 해석할 것이다. <br>
- **정수 자료형(char, int, long 등)은 부호를 가진다.**<br>
- 변수의 자료형이 signed int 일 경우 부호가 있는 것을 전제로 하기 때문에 내부적으로 1010(2)이 -2가 되고, 이것이 unsigned int라면 1010(2)는 10이 될 것이다.<br>
- 그래서 unsigned int는 양수밖에 표현할 수 없다. 또한 int는 4 byte의 메모리 크기를 차지하기 때문에 부호가 있는 signed int는 -2,147,483,648 - 2,147,483,647까지 담을 수 있는 것이고, unsinged int는 0 - 4,294,967,295까지 담을 수 있는 것이다.<br>
- C에서 기본 default는 signed int이기 때문에 signed는 편의상 제외한다.<br>

<br>

### 정수의 선언과 정의<br>

```
int a;   # 변수 선언 (초기화)
a = 10;  # 변수 정의

int a = 10;  # 변수 선언(초기화) 및 정의
```
변수이름은 용도에 맞는 분명한 의미를 나타내게 지어야한다.<br>
<br>

## char 형

<br>
char를 이해하기 위해선 <u>ASCII(아스키) 코드</u>를 알고 있어야 한다.
<br>

### ASCII 코드

- 컴퓨터에서는 글자도 숫자다.<br>
- 어떤 글자가 어떤 숫자인지 약속을 정해둔다.<br>
- 이러한 약속을 부호체계라고 한데,<br>
- 미국에서 정한 통일된 부호체계가 **ASCII 코드**다 <br>
- 아스키 코드는 글자를 7 bit로 128 가지를 지정할 수 있어 영문의 대소문자, 숫자, 특수문자까지 충분히 다룰 수 있다.<br>
- 7 bit에서 특수문자 중 특정 기호도 포함하기 위해 7 + 1 bit로 정하여서 최종적으로 8 bit를 기준으로 활용하게 된다. (8 bit = 1 byte)<br>

> ASCII 코드로 글자 'A' = 10진수로 65 = 16진수로 0x41 로 표현. (0x는 16진수라는 것을 의미) <br>
- 8 bit로 구분해 10진수로 계산하면 01000001 (2^6 + 2^0 = 65)
- 4 bit + 4 bit로 구분하여 16진수로 계산하면 0100 (4) 0001 (1)

> 다른 예로, 'J' = 10진수 74 = 16진수 0x4A이다.<br>
- 8 bit >> 　01001010 (2^6 + 2^3 + 2^0 = 74)
- 4 bit + 4 bit >> 　0100 (4) 1010 (A) 　　# 16진수에서 10 = A
<br>

### char과 int

<br>
아래 소스 코드의 출력결과를 통해 int와 char의 활용방식을 이해하자

```c
/* 
참고사항
- C언어는 같은 변수명을 중복하여 선언할 수 없다.
- 변수 정의 시 문자는 작은 따옴표로 감싸고, printf 내에는 큰 따옴표로 감싼다.
- printf에서 변수 출력할 때는 서식 문자(%d, %c)로 변수의 자료형을 적어야한다.
*/

#include <stdio.h>

int main(void)
{
    // 기본적으로 %d, %c 등 출력 형식에 따라간다.
    char x = 65;
    printf("%d\n", x);  // 65
    char y = 0x41;
    printf("%d\n", y);  // 65
    char z = 'A';
    printf("%d\n", z);  // 65

    // 10진수, 16진수, 문자 등 다양한 방식으로 선언
    int a = 65;
    printf("%d\n", a);  // 65
    int b = 0x41;
    printf("%d\n", b);  // 65
    int c = 'A';
    printf("%d\n", c);  // 65

    char d = 65;
    printf("%c\n", d);  // A
    char e = 0x41;
    printf("%c\n", e);  // A
    char f = 'A';
    printf("%c\n", f);  // A

  return 0;
}
```