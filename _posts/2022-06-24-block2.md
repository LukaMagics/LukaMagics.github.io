---
title: "[Blockchain] Private blockchain & Hyperledger (Fabric)"

categories:
  - bc
tags:
  - [bc, private blockchain, hyperledger]

toc: true
toc_sticky: true
comments: true
use_math: true
date: 2022-06-23
last_modified_at: 2022-06-23
---

📌 **작성자 개발 환경** <br>
**OS** : None <br>
**Language** : None <br>
**Tool** : None <br>
{: .notice--primary}

# 프라이빗 블록체인

- 프라이빗 블록체인 = 사적 블록체인, 폐쇄형 블록체인, 허가형 블록체인, 기업형 블록체인, 엔터프라이즈 블록체인
- 프라이빗 블록체인 네트워크에 참여하기 위해 한 명의 주체로부터 허가된 참여자만 참여하여 블록을 생성할 수 있어
- 프라이빗 블록체인은 미리 참가자를 제한하고 신뢰할 수 있는 참가자끼리 거래를 승인하기 때문에 합의 알고리즘이 퍼블릭 블록체인에 비해 간단하여서 네트워크 운영에 참여한 보상(코인)이 필요 없음
    - 참여자들이 컴퓨터 운영 비용을 부담하면 되기 때문에 암호화폐를 발행할 필요는 없음. 그러나 운영상 도입할 수도 있음
    - 다만, 해당 암호화폐는 외부의 암호화폐 거래소에 판매하기 어렵기 때문에 사실상 내부 정산 및 서비스 이용 등의 목적으로 제한적으로만 사용 가능
- 정보의 외부 유출을 원치 않고 처리 속도를 중요시하는 기업을 중심으로 개발되고 있으며, 고도의 보안을 필요로 하는 정부에서도 주로 이러한 형태로 블록체인 도입을 고려 중

## 퍼블릭 블록체인 vs 프라이빗 블록체인

|구분|퍼블릭 블록체인|프라이빗 블록체인|
|---|---|---|
|읽기 권한|누구나 열람 가능|허가된 기관만 열람 가능|
|거래 검증 및 승인|누구나 네트워크에 참여 하면 거래 검증 및 승인을 수행|승인된 기관과 감독 기관|
|트랜잭션 생성자|누구나 트랜잭션을 생성|법적 책임을 지는 기관만 참여|
|합의 알고리즘|부분 분기를 허용하는 작업 증명이나 지분증명 알고리즘|부분분기를 허용하지 않는 BFT계열의 합의 알고리즘|
|속도|7~20 TPS|1000 TPS이상의 고성능|
|권한 관리|모두가 모든 일을 할 수 있다.|Private Channel, Tiered System등을 통해 읽기 쓰기 권한 관리가 가능|
|예시|비트코인, 이더리움|IBM (Hyperledger)Fabric, LoopChain, R3 Corda|

- 트랜잭션 검증 요구사항에도 차이가 있어, 퍼블릭 블록체인의 경우 트랜잭션 내역 모두에게 공개되며 네트워크에 참여한 모든 노드가 트랜잭션을 검증하지만, 프라이빗 블록체인에서 이해관계자가 아닌 모든 노드가 트랜잭션의 검증하는 것은 문제가 있을 수 있다. 
- 노드별로 권한을 다르게 하는 것 또한 퍼블릭 블록체인에서는 불가능하여, 감독기관은 모든 데이터를 검증해야 하고 나머지 기관들은 자신에 관련된 데이터를 검증하는 등의 역할을 할 수 없으며, 퍼블릭 블록체인은 블록체인 엔진 수정이 어렵기 때문에 엔진에서 제공해야만 가능한 기능들을 추가하는 게 매우 어렵다

## 프랙티컬 비잔틴 장애 허용(PBFT)

- 프랙티컬 비잔틴 장애 허용은 작업증명(PoW)와 지분증명(PoS)의 단점인 파이널리티 불확실성과 성능 문제를 해결하는 합의 알고리즘이다.
- 대표적인 프라이빗 블록체인 오픈 소스 플랫폼 중 하나인 하이퍼레저 패브릭(Hyperledger Fabric)에서는 바로 이 PBFT 방식을 채택한다. 
- PBFT는 네트워크의 모든 참가자를 미리 알고 있어야 하는데, 참가자 중 한 명이 프라이머리가 되고 자신을 포함한 모든 참가자에게 요청을 보낸다. 그 요청에 대한 결과를 집계한 뒤 다수의 값을 사용해 블록을 확정한다. 
- PBFT 방식은 언제나 참가자 전원과 커뮤니케이션 해야 하므로 참가자가 늘어나면 통신량이 증가하고 처리량이 저하되며, 작업증명이나 지분증명은 수천, 수만 개의 노드를 만들 수 있지만 PBFT는 수십 개의 노드가 한계이다. 
- 상황에 맞는 최적의 합의 알고리즘을 선택하기 위해 더 많은 유스 케이스 발굴과 시범 서비스를 통한 검증이 필요하다.

# Hyperledger

- 하이퍼레저(Hyperledger)는 **스마트 계약을 구현할 수 있는 오픈소스 기반의 프라이빗 블록체인 프로젝트**
- 하이퍼레저는 금융, 사물인터넷(IoT), 물류, 제조, 기술 등 여러 산업에 걸쳐 응용 가능한 블록체인 기술을 만드는 것을 목표로 하고 있다.
- 리눅스재단(Linux Foundation)이 주관하고 있다.
- IBM 등 글로벌 대기업이 하이퍼레저 개발에 참여했으나, 이더리움 등 퍼블릭 블록체인에 밀려 2021년초 사실상 개발팀이 와해된 상황이다.

## Hyperledger의 두 갈래

- 하이퍼레저 프로젝트는 크게 두 갈래로 나뉜다. 하나는 하이퍼레저 프레임워크(Hyperledger Framework)이고, 다른 하나는 하이퍼레저 도구(Hyperledger Tool)이다.
    - 5개의 프레임워크: **패브릭(Fabric)**, 이로하(Iroha), 소투스(Sawtooth), 버로우(Burrow), 인디(Indy)
    - 5개의 도구: 퀼트(Quilt), 컴포저(Composer), 익스플로러(Explorer), 첼로(Cello), 켈리퍼(Caliper)

## Hyperledger 구성

- 신원서비스
- 정책서비스: 정책 서비스 기능을 사용하면 시스템 정책을 구성하고 관리할 수 ​​있다. 여기에는 출입통제 및 승인권한, 회원의 출입 및 출입규정, 신원등록 및 확인정책, 개인정보 보호, 기밀유지 및 책임정책, 합의정책 등을 포함하여 합의된 정관 및 규칙을 성문화하는 컨소시엄 정책이 포함
- 블록체인: 블록체인 서비스는 P2P 프로토콜, 분산원장 및 합의 관리자의 세 가지 핵심 구성 요소로 이루어져 있다
- 트랜잭션: 분산원장은 데이터 저장소를 사용하여 데이터 집합을 유지하고 세 가지 특성을 충족하는 상태를 나타내는 내부 데이터 구조를 작성
    - 대용량 파일(문서 등)은 장부(on-chain)가 아닌 외부(off-chain-storage)에 저장된다. 그들의 해시는 파일의 무결성을 유지하는 데 필요한 트랜잭션의 일부로 체인에 저장
- 스마트 계약: 스마트 계약은 유효성을 검사하는 노드에서 실행되는 분산 트랜잭션 프로그램. 스마트 계약 서비스에는 보안 런타임 환경, 스마트 계약 레지스트리 및 라이프 사이클 관리가 포함

## Hyperledger Fabric

- **하이퍼레저 패브릭**: 하이퍼레저 패브릭(Hyperledger Fabric)은 모듈형 구조로 응용 프로그램 및 솔루션 개발의 중심 역할을 수행한다. 의견 상의 일치 또는 회원 서비스와 같은 구성 요소를 플러그 앤드 플레이(plug and play) 방식으로 지원한다. **사실상 '하이퍼레저'라고 명명할 때에는 하이퍼레저 패브릭을 의미하는 경우가 많을 정도로**, 하이퍼레저 프로젝트 전체의 핵심이 되는 부분이다.
- 하이퍼레저 패브릭은 블록체인 프레임워크로서 리눅스 환경에서 호스팅하는 프로젝트이다. 오픈소스를 활용하여 비즈니스 환경의 기밀 유지와 확장성을 지원한다. 
- 컨테이너 기술을 활용하여 시스템의 응용 프로그램 로직을 구성하는 **체인코드(Chain Code)**라는 스마트 계약을 호스팅한다. 
- 하이퍼레저 패브릭은 **Java, Go, node.js와 같은 범용 프로그래밍 언어로 작성된 스마트 계약을 지원**하는 최초의 분산원장 플랫폼이다. 또한 **암호화폐 없이 합의 프로토콜**을 활용할 수 있다.
- 하이퍼레저 패브릭 1.1 버전은 분산원장(distributed ledger), 스마트 계약(smart contract), 합의(consensus), 기밀성(confidentiality), 탄력성(resiliency), 확장성(scalability) 등에 초점이 맞추어져 있다.

## Hyperledger 공식문서 필기

### Introduction

- **ledger**: 기록하는 곳? 블록체인에서는 블록이 Linked List 형태로 연결된 공간을 말하는 것? 블록체인 네트워크는 이 원장의 사본(**Copy**)을 공유하는 그룹.

- **Consensus**:  **네트워크를 통해 원장 트랜잭션을 동기화(Synchronize) 시키는 과정**을 컨센서스(합의) 라고 한다(원장의 사본을 일치시키는 것?).
  - 트랜잭션이 적절한 참여자에 의해 승인될 때만 원장이 업데이트되고, 트랜잭션이 원장이 업데이트될 때 트랜잭션이 일어난 순서대로 업데이트된다. 이를 위해선 트랜잭션의 순서를 정렬하고 bad 트랜잭션을 거절할 방법을 마련해야 한다. 이는 합의 알고리즘(메커니즘)의 규칙을 따른다.
  - Hyperledger fabric에서는 현재 네트워크 참가자의 관계에 따른 적합한 합의 알고리즘을 선택할 수 있다.

- **Channel**: Hyperledger Fabric은 채널을 생설할 수 있는데, 이 **채널에서 참여자 그룹이 별도의 거래 원장(transaction ledger)을 만들 수 있다**. 예를 들어, 두 명의 참가자가 채널을 구성하는 경우, 두 참가자는 해당 채널에 대한 원장의 사본을 가진다.

- Hyperledger Fabric 원장의 하위 시스템은 world state, transaction log 두 요소로 구성됨
  - **World state**: 지정된 시점의 원장 상태를 설명하는 것으로 **원장의 Database다**.
  - **Transaction log**: world state의 현재 값을 초래한 모든 트랜잭션을 기록. 즉, **world state에 대한 업데이트 기록**. 
  - 따라서 **원장은 world state database와 tansaction log history의 combination**이다.

- **Smart Contract(Chaincode)**: 스마트 컨트랙트는 애플리케이션이 **원장과 상호 작용할 때 블록체인 외부의 애플리케이션에 의해 호출**된다. 
  - **대부분의 경우**, 체인 코드는 원장의 tansaction log가 아닌 데이터베이스 요소인 **World State(예: Query)와만 상호 작용**한다.
  - 어플리케이션: OS와 같은 시스템 프로그램 외 응용 프로그램. 
  - Hyperledger의 경우, 체인 코드가 **Java, go, Node.js로 작성된 소스코드 파일(어플리케이션)로 구현됨**

### Hyperledger Fabric Model

- **Assets**: 유형과 무형 자산. **Chaincode** 트랜잭션을 활용해 수정 가능.
  - Assets은 channel 원장에 기록된 트랜잭션으로 **key-value 쌍 set**로 표현됨(**binary, JSON** 포멧)
- **Hyperledger의 Chaincode**: asset을 정의하는 SW(코드). **asset(key-value pairs)이나 데이터베이스의 state를 읽거나 바꾸는 규칙을 강제하는 코드**. 즉, 비즈니스 로직. 
- **Hyperledger의 consensus**
  - However, consensus encompasses more than simply agreeing upon the order of transactions, and this differentiation is highlighted in Hyperledger Fabric through its fundamental role in the entire transaction flow, from **proposal and endorsement, to ordering, validation and commitment**. In a nutshell, **consensus is** defined as the **full-circle verification of the correctness of a set of transactions comprising a block.**
  - Consensus is achieved ultimately when the order and results of a block’s transactions have **met the explicit policy criteria checks**.


### Block Chain Network

- N: 네트워크(Network)
- R: 조직(Organization)
- NC: 네트워크 구성(Network Configuration)
- O: 오더링 서비스(Ordering service; 주문X 트랜잭션 순서 정렬을 의미?)
- CA: 검증 기관(Certificate Authority)
- X: 컨소시엄 그룹
- C: 채널(Channel)
- CC: 채널 구성(Channel Configuration)
- P: 피어 노드(Peer node)
- L: 원장 인스턴스(Ledger instance, P에 의해 사본 호출?)
- S: 스마트 컨트랙트(Smart Contract)
- A: 어플리케이션(Application, 클라이언트 측)

- 네트워크(N) 생성 과정
  - Ordering Service O4 구현 단계: NC4가 O4의 구성, R4 관리자 권한부여 진행. N의 외부에서는 CA4 (관리자, 네트워크 노드, 유저의 신분 인증에 사용됨, MSP에 의해?)
- 클라이언트 측의 어플리케이션이 "네트워크->채널->노드->**원장**"에 도달하려면 **스마트 컨트랙트(체인 코드)**를 통해야 한다.
  - 체인 코드는 피어 노드(P)에 설치돼 있어야 하고, 채널(C)에 정의돼 있어야 한다. (단, 모든 피어 노드에 설치할 필요는 없다)
  - 체인 코드는 채널 범위에서만 작동하며, 채널의 관리자들(여러 R)이 모두 승인해야 설치될 수 있다. (채널 내 모든 요소들은 설치된 체인 코드에 접근할 수 있다)